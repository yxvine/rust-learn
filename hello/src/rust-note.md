# rust learn note

## 值放堆上还是放栈上?

内存、函数 的基本编程概念.

### 内存

```rust
let s = "hello world".to_string();
```

字符串常量如: "hello_world", 编译时被存入可执行文件的.RODATA 段(GCC), 
或.RDATA 段(VC++),然后在程序加载时,获得一个固定的内存地址.

**当执行 “hello world”.to_string() 时，在堆上，一块新的内存被分配出来，**
**并把 “hello world” 逐个字节拷贝过去**

堆上的数据赋值给s(分配在栈上的变量)时,需要知道堆内存的地址,
数据内容的长度,以及现在的长度.

### 数据什么时候放在堆上,什么时候放在栈上?

如何确定一个栈的大小? -> 由编译器进行管理,在编译器编译并优化代码的时候,
一个函数就是一个最小的编译单元,在编译的这个函数里面,编译器知道要用那些寄存器,
栈上要放哪些局部变量,都在编译时确定,所以编译器需要明确知道每个局部变量的大小,
以便预留空间.

**在编译时,一切无法确定大小或大小可以改变的数据,都无法安全地放在栈上,最好放在堆上.**

如字符串的数据结构，在编译时大小不确定，运行时执行到具体的代码才知道大小,
所以，我们无法把字符串本身放在栈上，只能先将其放在堆上，
然后在栈上分配对应的指针，引用堆上的内存。

栈上的内存的优缺点:

1. 分配非常高效(只需要移动栈指针),预留还释放,只需修改寄存器,不涉及额外的计算和系统调用,效率很高.

2. 避免大量数据分配在栈上或递归函数没有终止,导致栈溢出(程序崩溃).

### 堆

**当需要动态大小的内存时,只能使用堆,** 如可变长度数组,列表,哈希表,字典,都分配在堆上.
在堆上分配内存时,一般会预留一定的空间(最佳实践). 因为 在堆上分配内存需要调用系统调用.
所以要避免频繁的调用malloc. 

**动态生命周期的内存也要分配在堆上.**

堆上分配的内存需要显示地释放, 堆上的内存有更加灵活的生命周期,
可以在不同的调用栈之间共享数据.

堆上内存分配可能导致的问题:

1. 手工管理内存, 如果分配后忘记释放,就容易造成内存泄漏,吃完内存之后会被系统终止.
2. 堆内存,被多个调用栈共享,内存的改动,可能会导致堆越界的内存安全问题.(第一大内存安全问)
3. 如果堆内存已经被释放,但栈上指向堆上内存的指针没有被清空,则会导致:使用已释放内存, (第二大内存安全问题)

### 堆内存管理常见方案

#### GC

java 系列的语言使用追踪式垃圾回收(GC), 通过定期标记找出不再被引用的对象,然后清理掉.


#### ARC

objc, swift 使用 自动引用计数的方式,在编译时,
为每个函数插入retain/release 语句来自动维护堆上对象的引用计数,
当引用计数为0 时, release 就释放对象.

从效率上来说，GC 在内存分配和释放上无需额外操作，而 ARC 添加了大量的额外代码处理引用计数，所以 GC 效率更高，吞吐量（throughput）更大。
但是，GC 释放内存的时机是不确定的，释放时引发的 STW（Stop The World），也会导致代码执行的延迟（latency）不确定。所以一般携带 GC 的编程语言，不适于做嵌入式系统或者实时系统。

我们使用 Android 手机偶尔感觉卡顿，而 iOS 手机却运行丝滑，大多是这个原因。
而且做后端服务时，API 或者服务响应时间的 p99（99th percentile）也会受到 GC STW 的影响而表现不佳。
说句题外话，上面说的 GC 性能和我们常说的性能，涵义不太一样。常说的性能是吞吐量和延迟的总体感知，和实际性能是有差异的，GC 和 ARC 就是典型例子。GC 分配和释放内存的效率和吞吐量要比 ARC 高，但因为偶尔的高延迟，导致被感知的性能比较差，所以会给人一种 GC 不如 ARC 性能好的感觉。

### 小结

- 对于**存入栈上的值，它的大小在编译期就需要确定。**栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用。
堆可以存入大小未知或者动态伸缩的数据类型。
- 堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用。但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论是 GC 还是 ARC，都有性能损耗和其它问题。

一句话对比总结就是：

**栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。**
